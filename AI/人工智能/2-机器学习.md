## 人工智能简介

### 人工智能主要分支

- 计算机视觉(CV)：图像采集、图像处理、图像提取、图像推理、图像生成
- 自然语言处理(NLP)：让计算机处理、理解、生成文本的技术，还包括语音识别和语音生成
- 机器人(Robot)：研究机器人的设计、制造、运作和应用，以及控制它们的计算机系统、传感反馈和信息处理





## Numpy

numpy是python的一个三方库，意思是"Numeric Python"，它是一个有多维数组对象和处理数组的函数集合组成的库。numpy的数组（ndarray）在运算时是非常高效的，特别是在多维向量运算时远比python列表快得多。

> 张量（tensor）：表达N维数组的统称 TPU。张量是向量和矩阵的推广，单个数据即为 0维张量，一维数组是 1维张量，矩阵（二维数组）是 2维张量，那么三维数组也就是 3维张量，依次类推。
>
> ndarray(N-Dimension Array)：即 N维数组，是numpy中最重要的数组对象。ndarray中的每个元素在内存中使用相同大小的块，它描述相同类型的元素集合。这个集合中的元素是基于零的索引来进行访问。

### 创建ndarray

1. 将列表转为ndarray

   ```python
   import numpy as np
   
   # 将一维数组转为ndarray
   a = [1, 2, 3, 4]
   a1 = np.array(a)
   
   print(a1)  # [1 2 3 4]
   # 打印形状
   # ndarray.shape 返回一个元组，元祖的长度就是数组的维度，元组的元素表示当前维度的元素个数
   print(a1.shape)  # (4,)  一维 第一维有4个元素
   
   # 将二维数组转为ndarray
   b = [[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10]]
   b1 = np.array(b)
   
   print(b1)
   """
   [[ 1  2  3  4]
    [ 4  5  6  7]
    [ 7  8  9 10]]
   """
   print(b1.shape)  # (3, 4) 二维  第一维3个元素，第二维四个元素。也就是三行四列
   ```

2. 快速定义ndarray

   ```python
   import numpy as np
   
   # 创建一个 三行四列的数组，元素类型是 int，且元素初始值维0
   zeros = np.zeros(shape=(3, 4), dtype=int)
   print(zeros)
   """
   [[0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]]
   """
   
   # 创建一个 三维数组，元素类型是 float，且元素初始值维 1
   ones = np.ones(shape=(2, 3, 3), dtype=float)
   print(ones)
   """
   [[[1. 1. 1.]
     [1. 1. 1.]
     [1. 1. 1.]]
   
    [[1. 1. 1.]
     [1. 1. 1.]
     [1. 1. 1.]]]
   """
   
   # 生成一个元素个数为 15 的一维数组，元素值从 1-50 取随机值
   randint = np.random.randint(1, 50, 15)
   print(randint)  # [44 15 11 36 10 43 34 15 45 16 40 23  7  3 18]
   
   # 生成一个元素个数为 20 的一维数组，元素值为 0-1 之间的随机小数
   random = np.random.random(20)
   print(random)
   """
   [0.35659616 0.63290736 0.78780876 0.23482026 0.75922391 0.84146319
    0.48184927 0.85644156 0.01635306 0.50068861 0.66140974 0.35190128
    0.31168905 0.22555912 0.27385962 0.8691914  0.99481466 0.02672019
    0.54940247 0.02429207]
   """
   
   # 生成等差数列
   # arange 是左开右闭，通过指定步长来得到一个等差数据
   # linspace 是左开右开，通过参数指定等差数列的个数，无法指定步长
   # 生成 1-60 之间，等差为 3 的等差数列
   diff = np.arange(1, 60, 3)
   print(diff)  # [ 1  4  7 10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58]
   
   # 生成 1-10 之间，长度为 20 的一维等差数列数组
   diff2 = np.linspace(1, 10, 20)
   print(diff2)
   """
   [ 1.          1.47368421  1.94736842  2.42105263  2.89473684  3.36842105
     3.84210526  4.31578947  4.78947368  5.26315789  5.73684211  6.21052632
     6.68421053  7.15789474  7.63157895  8.10526316  8.57894737  9.05263158
     9.52631579 10.        ]
   """
   
   # 创建一个三行三列对角线为1的矩阵
   diff3 = np.eye(3)
   print(diff3)
   """
   [[1. 0. 0.]
    [0. 1. 0.]
    [0. 0. 1.]]
   """
   
   # 根据列表创建对角线数组
   diff4 = np.diag([2, 3, 4, 5])
   print(diff4)
   """
   [[2 0 0 0]
    [0 3 0 0]
    [0 0 4 0]
    [0 0 0 5]]
   """
   ```

### 数组操作

1. 常用方法

   ```python
   import numpy as np
   
   a = [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
   
   a1 = np.array(a)
   
   print(a1.shape)  # 形状 (12,)
   print(a1.size)  # 12 返回多维数组中总共的元素个数
   print(a1.dtype)  # int64  返回数组中元素的 类型
   print(a1.ndim)  # 1 返回素组的维度
   
   # 变形
   a2 = a1.reshape((3, 4))  # 把第一位变为3个元素，第二维变成四个元素，就是三行四列，总共还是 12 个元素
   print(a2.shape)  # (3, 4)
   print(a2.ndim)  # 2
   
   a3 = a2.reshape(6, -1)  # 第一维变成6个元素，第二维自动分配元素个数。以供12个元素，那自动分配第二维就该是2个元素
   print(a3.shape)  # (6, 2)
   
   a4 = a3.reshape(-1, 3)  # 第一维自动分配，第二维分配3个元素，那么第一维就该四个
   print(a4.shape)  # (4, 3)
   
   # 展平，把多维数组拉成一维数组
   a5 = a4.flatten()
   print(a5)  # [ 9 10 11 12 13 14 15 16 17 18 19 20]
   print(a5.shape)  # (12,)
   
   # 通过重新指定数组图形，来修改数组的大小，注意这个过程是就地修改
   # 将12个元素resize为9个元素，剩余的丢弃
   a5.resize((3, 3))
   print(a5)
   """
   [[ 9 10 11]
    [12 13 14]
    [15 16 17]]
   """
   
   # 继续resize，把9个元素resize为16个元素，不足的按当前数据类型的默认值补齐
   a5.resize((4, 4))
   print(a5)
   """
   [[ 9 10 11 12]
    [13 14 15 16]
    [17  0  0  0]
    [ 0  0  0  0]]
   """
   ```

2. 数组运算

   ```python
   import numpy as np
   
   a = [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
   
   a1 = np.array(a)
   
   # 单个数组元素的 算数运算
   print(a1 + 3)  # 数组每个元素都加3  [12 13 14 15 16 17 18 19 20 21 22 23]
   print(a1 - 4)  # 所有元素减4  [ 5  6  7  8  9 10 11 12 13 14 15 16]
   print(a1 * 2)  # 乘法  [18 20 22 24 26 28 30 32 34 36 38 40]
   print(a1 / 2)  # 除法  [ 4.5  5.   5.5  6.   6.5  7.   7.5  8.   8.5  9.   9.5 10. ]
   
   # 多个数组间的 算数运算。两个数组进行运算，必须元素个数和形状是相同的
   # 两个数组的运算是 点对点 的
   b = [1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2]
   b1 = np.array(b)
   
   print(a1 + b1)  # 两个数组相加 [10 12 14 16 18 20 22 22 22 22 22 22]
   print(a1 - b1)  # [ 8  8  8  8  8  8  8 10 12 14 16 18]
   print(a1 * b1)  # [  9  20  33  48  65  84 105  96  85  72  57  40]
   print(a1 / b1)  # [ 9. 5. 3.66666667  3. 2.6 2.33333333 2.14285714 2.66666667 3.4 4.5 6.33333333 10. ]
   
   # 函数形式的乘和除
   print(np.multiply(a1, b1))  # [  9  20  33  48  65  84 105  96  85  72  57  40]
   print(np.divide(a1, b1))  # [ 9. 5. 3.66666667  3. 2.6 2.33333333 2.14285714 2.66666667 3.4 4.5 6.33333333 10. ]
   ```

3. 矩阵乘法

   矩阵乘法的规则：矩阵A的列数必须等于矩阵B的行数，才能相乘。

   `A(M行, N列) * B(N行, P列) = C(M行, P列)`

   <img src='./images/screenshot-015.png' style='float: left; width: 75%'>

   在np中进行两个数组的矩阵乘法运算：

   ```python
   import numpy as np
   
   a = np.array([[3, 4, 6], [4, 7, 9], [2, 5, 8]])
   b = np.array([[11, 12], [21, 22], [31, 32]])
   
   print(np.dot(a, b))
   """
   [[303 316]
    [470 490]
    [375 390]]
   """
   ```

   

4. 其他运算

   ```python
   import numpy as np
   
   a = [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
   
   a1 = np.array(a)
   a1 = a1.reshape((4, 3))  # 变形
   
   print(np.sum(a1))  # 174 对多维数组元素求和
   print(np.average(a1))  # 14.5 对数组元素求平均值
   print(np.mean(a1))  # 14.5 对数组计算 算数平均数
   print(np.std(a1))  # 3.452052529534663 计算标准差
   print(np.var(a1))  # 11.916666666666666 计算方差
   print(np.min(a1))  # 9  最小值
   print(np.max(a1))  # 20 最大值
   print(np.median(a1))  # 14.5 计算中间值
   
   # 旋转图形角度
   print(a1)
   """
   [[ 9 10 11]
    [12 13 14]
    [15 16 17]
    [18 19 20]]
   """
   print(np.rot90(a1))  # 逆时针旋转90度
   """
   [[11 14 17 20]
    [10 13 16 19]
    [ 9 12 15 18]]
   """
   print(np.rot90(a1, k=3))  # 逆时针旋转270度，k 表示几个90，默认1
   """
   [[18 15 12  9]
    [19 16 13 10]
    [20 17 14 11]]
   """
   
   # 其他特殊运算
   print(np.power(a1, 3))  # 求各元素的N次方
   """
   [[ 729 1000 1331]
    [1728 2197 2744]
    [3375 4096 4913]
    [5832 6859 8000]]
   """
   print(np.exp(a1))  # 计算 自然对数e ，数组元素为次方的值
   """
   [[8.10308393e+03 2.20264658e+04 5.98741417e+04]
    [1.62754791e+05 4.42413392e+05 1.20260428e+06]
    [3.26901737e+06 8.88611052e+06 2.41549528e+07]
    [6.56599691e+07 1.78482301e+08 4.85165195e+08]]
   """
   print(np.log(a1))  # 计算以 自然对数e 为底数，数组元素为 真数的 指数
   """
   [[2.19722458 2.30258509 2.39789527]
    [2.48490665 2.56494936 2.63905733]
    [2.7080502  2.77258872 2.83321334]
    [2.89037176 2.94443898 2.99573227]]
   """
   print(np.log2(a1))  # 计算以 2 为底数，数组元素为 真数的 指数
   """
   [[3.169925   3.32192809 3.45943162]
    [3.5849625  3.70043972 3.80735492]
    [3.9068906  4.         4.08746284]
    [4.169925   4.24792751 4.32192809]]
   """
   print(np.log10(a1))  # 计算以 10 为底数，数组元素为 真数的 指数
   """
   [[0.95424251 1.         1.04139269]
    [1.07918125 1.11394335 1.14612804]
    [1.17609126 1.20411998 1.23044892]
    [1.25527251 1.2787536  1.30103   ]]
   """
   ```

   > 总体方差（Population Variance）的公式如下：
   >
   > $$
   > \sigma^2 = \frac{1}{N} \sum_{i=1}^{N} (X_i - \mu)^2
   > \\
   > 其中：
   > \sigma^2 表示总体方差，N 是总体中数据点的总数，X_i 是第 i 个数据点的值，\mu 是总体的均值（计算公式：\mu = \frac{1}{N} \sum_{i=1}^{N} X_i）
   > $$
   >
   > 总体标准差（Standard Deviation），是在方差的基础上开根，公示如下：
   > $$
   > \sigma = \sqrt{\frac{1}{N} \sum_{i=1}^{N} (X_i - \mu)^2}
   > \\
   > 其中：
   > \sigma 表示总体标准差，N 是总体中数据点的总数，X_i 是第 i 个数据点的值，\mu 是总体的均值（计算公式：\mu = \frac{1}{N} \sum_{i=1}^{N} X_i）
   > $$
   > 除开总体方差和标准差，对于大量数据通常从总体中随机抽取一定数量的样本，通过样本来估计总体的方差和标准差。样本标准差同样是在样本方差的基础上开根，公示如下：
   > $$
   > \sigma = \sqrt{\frac{1}{n - 1} \sum_{i=1}^{n} (X_i - \mu)^2}
   > \\
   > 其中：
   > 这里使用[n-1]，而非样本数量[n]作为分母，这个校正被称为[贝塞尔校正]
   > $$



